import{_ as e,o as i,c as a,e as s}from"./app-c5939a72.js";const t={},n=s(`<p>大多数情况下，看提交历史的人跟提交代码的人都不是同一个人，当别人阅读你的提交历史时，他很可能是不知道具体代码细节的，你如何在最短的时间内让他一眼知道每次提交的意义：</p><p>每次提交影响的具体范围？ 这个bug在哪次提交中被修复了？ 这个新功能是在哪次提交中增加的？ 修改是否向下兼容？ 是否回滚了代码？ 是否只是修改了文档、调整了代码格式？ 是否修改了测试、是否进行了重构？ 是否对代码进行了性能优化？</p><p>这些都是提交规范的作用。</p><h2 id="git-提交commit" tabindex="-1"><a class="header-anchor" href="#git-提交commit" aria-hidden="true">#</a> git 提交commit</h2><p>每个类型值都表示了不同的含义，类型值必须是以下的其中一个：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>feat：提交新功能
fix：修复了bug
docs：只修改了文档
style：调整代码格式，未修改代码逻辑（比如修改空格、格式化、缺少分号等）
refactor：代码重构，既没修复bug也没有添加新功能
perf：性能优化，提高性能的代码更改
test：添加或修改代码测试
chore：对构建流程或辅助工具和依赖库（如文档生成等）的更改
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="git-clean-删除依赖更新包" tabindex="-1"><a class="header-anchor" href="#git-clean-删除依赖更新包" aria-hidden="true">#</a> git clean 删除依赖更新包</h2><p>git clean 从你的工作目录中删除所有没有 tracked，没有被管理过的文件,删除工作中所有node_modules依赖项</p><p>未添加到版本控制，且不在.gitignore中的，都是Untracked的状态</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>n ：查看将要被删除的文件，并不实际删除文件

d ：删除未跟踪目录以及目录下的文件，如果目录下包含其他git仓库文件，并不会删除（-dff可以删除）。（将 .gitignore 文件标记的文件全部删除）

f ：如果 git cofig 下的 clean.requireForce 为true，那么clean操作需要-f(--force)来强制执行

x ：删除没有被 track 的文件
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>强制删除依赖</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>git clean -dfx
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="git-stash" tabindex="-1"><a class="header-anchor" href="#git-stash" aria-hidden="true">#</a> git stash</h2><p>场景:在当前分支进行迭代开发，突然有线上bugfix,但是还不想把现在的修改提交，也不希望在Git上看到当前修改的版本</p><p>git stash会把所有未提交的修改（包括暂存的和非暂存的）都保存起来，用于后续恢复当前工作目录。 比如下面的中间状态，通过git stash命令推送一个新的储藏，当前的工作目录就干净了。</p><blockquote><p>stash是本地的，不会通过git push命令上传到git server上</p></blockquote><h3 id="缓存本地-list查看" tabindex="-1"><a class="header-anchor" href="#缓存本地-list查看" aria-hidden="true">#</a> 缓存本地 &amp; list查看</h3><p>推荐stash加一个message，用于记录版本，使用git stash save取代git stash命令 git stash list</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>git stash save &quot;test-stash&quot;

git stash list

stash@{0}: On autoswitch: test-stash
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="重新应用缓存" tabindex="-1"><a class="header-anchor" href="#重新应用缓存" aria-hidden="true">#</a> 重新应用缓存</h3><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>git stash pop
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这个指令将缓存堆栈中的第一个stash删除，并将对应修改应用到当前的工作目录</p><p>可以使用<code>git stash apply</code>命令，将缓存堆栈中的stash多次应用到工作目录中，但并不删除stash拷贝</p><h3 id="移除stash" tabindex="-1"><a class="header-anchor" href="#移除stash" aria-hidden="true">#</a> 移除stash</h3><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>git stash drop  stash@{0}   
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>后面可以跟着stash名字 或者使用<code>git stash clear</code>命令，删除所有缓存的stash</p><h3 id="查看指定stash的diff" tabindex="-1"><a class="header-anchor" href="#查看指定stash的diff" aria-hidden="true">#</a> 查看指定stash的diff</h3><p>使用<code>git stash show</code>命令，后面可以跟着stash名字 在该命令后面添加-p或--patch可以查看特定stash的全部diff</p><h2 id="关联指定orgin仓库" tabindex="-1"><a class="header-anchor" href="#关联指定orgin仓库" aria-hidden="true">#</a> 关联指定orgin仓库</h2><ol><li><p>git init (初始化)</p></li><li><p>git remote add origin remoteUrl(设置远程remote地址)</p></li><li><p>git pull origin master (拉取远程仓库master文件)</p></li><li><p>git branch --set-upstream-to=origin/master master (将本地master设置为远程master分支)</p></li><li><p>git add .</p></li><li><p>git commit -m &#39;xx&#39;</p></li><li><p>git push</p></li></ol><h2 id="重命名仓库" tabindex="-1"><a class="header-anchor" href="#重命名仓库" aria-hidden="true">#</a> 重命名仓库</h2><h3 id="重命名本地分支" tabindex="-1"><a class="header-anchor" href="#重命名本地分支" aria-hidden="true">#</a> 重命名本地分支</h3><ul><li>在当前分支</li></ul><ol><li>git branch -m new_branch_name</li></ol><ul><li>不在当前分支</li></ul><ol><li>git branch -m old_branch_name new_branch_name</li></ol><h3 id="重命名远端分支-在当前分支且与远端分支名称一致" tabindex="-1"><a class="header-anchor" href="#重命名远端分支-在当前分支且与远端分支名称一致" aria-hidden="true">#</a> 重命名远端分支（在当前分支且与远端分支名称一致）</h3><ul><li>重命名本地分支</li></ul><ol><li>git branch -m new_branch_name</li></ol><ul><li>删除远程分支</li></ul><ol><li>git push --delete origin old_branch_name</li></ol><ul><li>上传新命名的本地分支</li></ul><ol><li>git push origin new_branch_name</li></ol><ul><li>关联修改后的本地与远端分支</li></ul><ol><li>git branch --set-upstream-to origin/new_branch_name</li></ol>`,45),l=[n];function d(r,c){return i(),a("div",null,l)}const o=e(t,[["render",d],["__file","git.html.vue"]]);export{o as default};
